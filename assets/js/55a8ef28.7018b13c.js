"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4245],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=d(t),m=r,h=u["".concat(l,".").concat(m)]||u[m]||c[m]||i;return t?a.createElement(h,o(o({ref:n},p),{},{components:t})):a.createElement(h,o({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},3511:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return p},default:function(){return u}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),o=["components"],s={id:"datatx",title:"Data Transaction"},l="Data Transaction",d={unversionedId:"getting-started/transactions/gosdk/datatx",id:"getting-started/transactions/gosdk/datatx",isDocsHomePage:!1,title:"Data Transaction",description:"We can create, update, and delete states maintained by the Orion cluster using data transactions.",source:"@site/docs/getting-started/transactions/gosdk/datatx.md",sourceDirName:"getting-started/transactions/gosdk",slug:"/getting-started/transactions/gosdk/datatx",permalink:"/orion-server/docs/getting-started/transactions/gosdk/datatx",tags:[],version:"current",frontMatter:{id:"datatx",title:"Data Transaction"},sidebar:"Documentation",previous:{title:"User Administration Transaction",permalink:"/orion-server/docs/getting-started/transactions/gosdk/usertx"},next:{title:"Database Administration Transaction",permalink:"/orion-server/docs/getting-started/transactions/curl/dbtx"}},p=[{value:"1) Create new states in database",id:"1-create-new-states-in-database",children:[{value:"1.1) Source Code",id:"11-source-code",children:[],level:3},{value:"1.2) Source Code Commentary",id:"12-source-code-commentary",children:[],level:3}],level:2},{value:"2) Update an existing state",id:"2-update-an-existing-state",children:[{value:"2.1) Source Code",id:"21-source-code",children:[],level:3},{value:"2.2) Soure Code Commentary",id:"22-soure-code-commentary",children:[],level:3}],level:2},{value:"3) Delete an existing state",id:"3-delete-an-existing-state",children:[{value:"3.1) Source Code",id:"31-source-code",children:[],level:3},{value:"3.2) Source Code Commentary",id:"32-source-code-commentary",children:[],level:3}],level:2},{value:"4) Create, update, and delete states within a single transaction",id:"4-create-update-and-delete-states-within-a-single-transaction",children:[{value:"4.1) Source Code",id:"41-source-code",children:[],level:3},{value:"4.2) Source Code Commentary",id:"42-source-code-commentary",children:[],level:3}],level:2},{value:"5) Operations on Multiple Databases in a Single Transaction",id:"5-operations-on-multiple-databases-in-a-single-transaction",children:[{value:"5.1) Source Code",id:"51-source-code",children:[],level:3},{value:"5.2) Source Code Commentary",id:"52-source-code-commentary",children:[],level:3}],level:2}],c={toc:p};function u(e){var n=e.components,t=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"data-transaction"},"Data Transaction"),(0,i.kt)("p",null,"We can create, update, and delete states maintained by the Orion cluster using data transactions."),(0,i.kt)("p",null,"Using a data transaction, we can do the following:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#1-create-new-states"},"Create new states")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#2-update-an-existing-state"},"Update existing states")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#3-delete-an-existing-state"},"Delete existing states")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#4-create-update-delete-states-within-a-single-transaction"},"Create, update, and delete states within a single transaction")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#5-operations-on-multiple-databases-in-a-single-transaction"},"Operations on multiple databases")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#6-multi-signatures-transaction"},"Multi-signatures transaction"))),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"prerequisite")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For all examples shown here to work, we need to have"),(0,i.kt)("ol",{parentName:"div"},(0,i.kt)("li",{parentName:"ol"},"Two databases named ",(0,i.kt)("inlineCode",{parentName:"li"},"db1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"db2")," in the Orion server. If you have not created these two databases,\nrefer to ",(0,i.kt)("a",{parentName:"li",href:"./dbtx#creation-of-databases"},"creates databases using SDK")," create ",(0,i.kt)("inlineCode",{parentName:"li"},"db1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"db2"),"."),(0,i.kt)("li",{parentName:"ol"},"Two users named ",(0,i.kt)("inlineCode",{parentName:"li"},"alice")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"bob"),". If you have not created these users already, refer to ",(0,i.kt)("a",{parentName:"li",href:"./usertx##2-addition-of-users"},"create users using SDK"),".")),(0,i.kt)("p",{parentName:"div"},"Finally, ",(0,i.kt)("a",{parentName:"p",href:"../../pre-requisite/gosdk#creating-a-connection-to-the-orion-cluster"},"Create a connection")," and\n",(0,i.kt)("a",{parentName:"p",href:"../../pre-requisite/gosdk#opening-a-database-session"},"Open a database session"),"."))),(0,i.kt)("p",null,"Once a ",(0,i.kt)("a",{parentName:"p",href:"./../../pre-requisite/gosdk#opening-a-database-session"},"database session")," is created, a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"session.DataTx()")," will create a new data transaction context and thus will start a new data\ntransaction. The data transaction context provides the following methods to calls:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'type DataTxContext interface {\n    // Put new value to key\n    Put(dbName string, key string, value []byte, acl *types.AccessControl) error\n    // Get existing key value\n    Get(dbName, key string) ([]byte, *types.Metadata, error)\n    // Delete value for key\n    Delete(dbName, key string) error\n    // AssertRead insert a key-version to the transaction assert map\n    AssertRead(dbName string, key string, version *types.Version) error\n    // AddMustSignUser adds userID to the multi-sign data transaction\'s\n    // MustSignUserIDs set. All users in the MustSignUserIDs set must co-sign\n    // the transaction for it to be valid. Note that, in addition, when a\n    // transaction modifies keys which have multiple users in the write ACL,\n    // or when a transaction modifies keys where each key has different user\n    // in the write ACL, the signature of additional users may be required.\n    // AddMustSignUser can be used to add users whose signatures is required,\n    // on top of those mandates by the ACLs of the keys in the write-set of\n    // the transaction. The userID of the initiating client is always in\n    // the MustSignUserIDs set."\n    AddMustSignUser(userID string)\n    // SignConstructedTxEnvelopeAndCloseTx returns a signed transaction envelope and\n    // also closes the transaction context. When a transaction requires\n    // signatures from multiple users, an initiating user prepares the\n    // transaction and calls SignConstructedTxEnvelopeAndCloseTx in order to\n    // sign it and construct the envelope. The envelope must then be\n    // circulated among all the users that need to co-sign it."\n    SignConstructedTxEnvelopeAndCloseTx() (proto.Message, error)\n    // Commit submits transaction to the server, can be sync or async.\n    // Sync option returns tx id and tx receipt and\n    // in case of error, commitTimeout error is one of possible errors to return.\n    // Async returns tx id, always nil as tx receipt or error\n    Commit(sync bool) (string, *types.TxReceipt, error)\n    // Abort cancel submission and abandon all changes\n    // within given transaction context\n    Abort() error\n    // CommittedTxEnvelope returns transaction envelope, can be called only after Commit(), otherwise will return nil\n    CommittedTxEnvelope() (proto.Message, error)\n}\n')),(0,i.kt)("h2",{id:"1-create-new-states-in-database"},"1) Create new states in database"),(0,i.kt)("h3",{id:"11-source-code"},"1.1) Source Code"),(0,i.kt)("p",null,"Let's store a new state ",(0,i.kt)("inlineCode",{parentName:"p"},"key1")," with the value ",(0,i.kt)("inlineCode",{parentName:"p"},'{"name":"abc","age":31,"graduated":true}'),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "encoding/json"\n    "fmt"\n    "strconv"\n\n    "github.com/hyperledger-labs/orion-server/pkg/types"\n)\n\ntype person struct {\n    Name      string `json:"name"`\n    Age       int64  `json:"age"`\n    Graduated bool   `json:"graduated"`\n}\n\nfunc main() {\n    db, err := createConnection()\n    // if err is not nil, print and return\n\n    session, err := openSession(db, "alice")\n    // if err is not nil, print and return\n\n    tx, err := session.DataTx()\n    // if err is not nil, print and return\n\n    p := &person{\n        Name:      "abc",\n        Age:       31,\n        Graduated: true,\n    }\n\n    jVal, err := json.Marshal(p)\n    // if err is not nil, print and return\n\n    acl := &types.AccessControl{\n        ReadUsers: map[string]bool{\n            "bob":   true,\n        },\n        ReadWriteUsers: map[string]bool{\n            "alice": true,\n        },\n        SignPolicyForWrite: types.AccessControl_ANY,\n    }\n    err = tx.Put("db2", "key1", jVal, acl)\n    // if err is not nil, print and return\n\n    txID, receipt, err := tx.Commit(true)\n    // if err is not nil, print and return\n\n    fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))\n}\n')),(0,i.kt)("h3",{id:"12-source-code-commentary"},"1.2) Source Code Commentary"),(0,i.kt)("p",null,"For the sake of simplicity, not all errors are handled in this code. Furthermore, the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"createConnection()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"openSession()")," can be found ",(0,i.kt)("a",{parentName:"p",href:"../../pre-requisite/gosdk"},"here"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"session.DataTx()")," starts a new data transaction and returns the data transaction context. We can then perform all\ndata manipulation activities using this transaction context."),(0,i.kt)("p",null,"Let's create a key ",(0,i.kt)("inlineCode",{parentName:"p"},"key1")," with the value ",(0,i.kt)("inlineCode",{parentName:"p"},'{"name":"abc","age":31,"graduated":true}'),". In the above code, we use the struct with JSON tags and then marshal the struct to create this JSON value."),(0,i.kt)("p",null,"Once the value is created, we define the access control for this key ",(0,i.kt)("inlineCode",{parentName:"p"},"key1"),". The structure of ACL is shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type AccessControl struct {\n    ReadUsers            map[string]bool\n    ReadWriteUsers       map[string]bool\n    SignPolicyForWrite   AccessControlWritePolicy\n}\n\ntype AccessControlWritePolicy int32\n\nconst (\n    AccessControl_ANY AccessControlWritePolicy = 0\n    AccessControl_ALL AccessControlWritePolicy = 1\n)\n")),(0,i.kt)("p",null,"The ACL holds"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ReadUsers"),": a list of users who can only read the key"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ReadWriteUsers"),": a list of users who can read and write the key."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"SignPolicyForWrite"),": denotes whether signature of all users in the ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadWriteUsers")," is needed to perform writes to the key.")),(0,i.kt)("p",null,"The following are various ACL configurations and associated effects:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"If the ACL is ",(0,i.kt)("inlineCode",{parentName:"li"},"nil")," for a key, any users of Orion can access that key."),(0,i.kt)("li",{parentName:"ol"},"If the ACL has only ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadUsers")," for a key, then the key would become read-only forever by users present in the ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadUsers")," list."),(0,i.kt)("li",{parentName:"ol"},"If the ACL has ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadWriteUsers")," for a key, users in this list can read and write that key. As ",(0,i.kt)("inlineCode",{parentName:"li"},"SignPolicyForWrite")," is not set, it uses the default policy which is ",(0,i.kt)("inlineCode",{parentName:"li"},"AccessControl_ANY"),". This means that any user in the ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadWriteUsers")," can write to the key."),(0,i.kt)("li",{parentName:"ol"},"If the ACL has only ",(0,i.kt)("inlineCode",{parentName:"li"},"SignPolicyForWrite")," but ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadUsers")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadWriteUsers")," are empty for a key, then no user can read or write to that key forever."),(0,i.kt)("li",{parentName:"ol"},"If the ACL has ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadWriteUsers")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"AccessControl_ALL")," for the ",(0,i.kt)("inlineCode",{parentName:"li"},"SignPolicyForWrite"),", then the key can be read by any users in the ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadWriteUsers")," but only when all the users sign the transaction, can the key be updated or deleted."),(0,i.kt)("li",{parentName:"ol"},"If the ACL has ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadUsers")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"SignPolicyForWrite")," for a key, then the key would become read-only forever by users present in the ",(0,i.kt)("inlineCode",{parentName:"li"},"ReadUsers")," list.")),(0,i.kt)("p",null,"In our code, we have provided the read access on ",(0,i.kt)("inlineCode",{parentName:"p"},"key1")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"alice")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bob")," but only ",(0,i.kt)("inlineCode",{parentName:"p"},"alice")," can write to the key. As there is a\nsingle user in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadWriteUsers"),", we have set the ",(0,i.kt)("inlineCode",{parentName:"p"},"SignPolicyForWrite")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"AccessControl_ANY"),". Even if we set\n",(0,i.kt)("inlineCode",{parentName:"p"},"SignPolicyForWrite")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"AccessControl_ALL"),", it works, as only ",(0,i.kt)("inlineCode",{parentName:"p"},"alice")," has the write permission on ",(0,i.kt)("inlineCode",{parentName:"p"},"key1"),"."),(0,i.kt)("p",null,"We then use ",(0,i.kt)("inlineCode",{parentName:"p"},"tx.Put()")," to store the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key1")," with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"jVal")," and an access control list ",(0,i.kt)("inlineCode",{parentName:"p"},"acl")," in the database ",(0,i.kt)("inlineCode",{parentName:"p"},"db2"),"."),(0,i.kt)("p",null,"Finally, the transaction is committed by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"dbtx.Commit(true)"),". The argument true denotes that this is a synchronous submission. As a result, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Commit()"),"\nreturns the transaction receipt if this transaction gets committed before the ",(0,i.kt)("inlineCode",{parentName:"p"},"TxTimeout")," configured in the ",(0,i.kt)("inlineCode",{parentName:"p"},"openSession()"),"."),(0,i.kt)("p",null,"The structure of txReceipt can be seen ","[here]",". The user can store this txReceipt, as it is a commitment used to verify the proof generated by the server."),(0,i.kt)("p",null,"Refer to ",(0,i.kt)("a",{parentName:"p",href:"../../queries/gosdk/simple-data-query"},"Query Data")," in queries to check whether ",(0,i.kt)("inlineCode",{parentName:"p"},"key1")," has been created."),(0,i.kt)("h2",{id:"2-update-an-existing-state"},"2) Update an existing state"),(0,i.kt)("h3",{id:"21-source-code"},"2.1) Source Code"),(0,i.kt)("p",null,"Let's update the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"key1"),". To do that, we need to execute the following three steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Fetch ",(0,i.kt)("inlineCode",{parentName:"li"},"key1")," from the server."),(0,i.kt)("li",{parentName:"ol"},"Construct the updated value.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"update the ",(0,i.kt)("inlineCode",{parentName:"li"},"age")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"31"),". The new value would be ",(0,i.kt)("inlineCode",{parentName:"li"},'{"name":"abc","age":32,"graduated":true}')))),(0,i.kt)("li",{parentName:"ol"},"Commit the data transaction.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "encoding/json"\n    "fmt"\n    "strconv"\n)\n\ntype person struct {\n    Name      string `json:"name"`\n    Age       int64  `json:"age"`\n    Graduated bool   `json:"graduated"`\n}\n\nfunc main() {\n    db, err := createConnection()\n    // if err is not nil, print and return\n\n    session, err := openSession(db, "alice")\n    // if err is not nil, print and return\n\n    tx, err := session.DataTx()\n    // if err is not nil, print and return\n\n    v, m, err := tx.Get("db2", "key1")\n    // if err is not nil, print and return\n\n    p := &person{}\n    err = json.Unmarshal(v, p)\n    // if err is not nil, print and return\n\n    p.Age = 32\n\n    jVal, err := json.Marshal(p)\n    // if err is not nil, print and return\n\n    err = tx.Put("db2", "key1", jVal, m.AccessControl)\n    // if err is not nil, print and return\n\n    txID, receipt, err := tx.Commit(true)\n    // if err is not nil, print and return\n\n    fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))\n}\n')),(0,i.kt)("h3",{id:"22-soure-code-commentary"},"2.2) Soure Code Commentary"),(0,i.kt)("p",null,"For the sake of simplicity, not all errors are handled in this code. Further, the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"createConnection()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"openSession()"),"\ncan be found ",(0,i.kt)("a",{parentName:"p",href:"../../pre-requisite/gosdk"},"here"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"session.DataTx()")," starts a new data transaction and returns the data transaction context. We can then perform all data manipulation activities using this transaction context."),(0,i.kt)("p",null,"As we need to update the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"key1"),", first we need to fetch ",(0,i.kt)("inlineCode",{parentName:"p"},"key1")," from the Orion server by calling ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Get("db2", "key1")'),".\nThe fetched value is ",(0,i.kt)("inlineCode",{parentName:"p"},"[]byte")," and it holds the JSON marshalled value. We need to unmarshal it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"person")," object. From\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"person")," object, it is easy to change the ",(0,i.kt)("inlineCode",{parentName:"p"},"Age")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"32"),"."),(0,i.kt)("p",null,"Once the fetched value is updated locally, we need to marshal it again by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"json.Marshal()")," and store the updated marshalled value by calling ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Put("db2", "key1", jVal, m.AccessControl)'),". Note that we are passing the same access control as we are not making any changes to it."),(0,i.kt)("p",null,"Finally, the transaction is committed by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"dbtx.Commit(true)"),'. The argument "true" denotes that this is a synchronous submission. As a result, the ',(0,i.kt)("inlineCode",{parentName:"p"},"Commit()"),"\nreturns the transaction receipt if this transaction gets committed before the ",(0,i.kt)("inlineCode",{parentName:"p"},"TxTimeout")," configured in the ",(0,i.kt)("inlineCode",{parentName:"p"},"openSession()"),"."),(0,i.kt)("p",null,"The structure of txReceipt can be seen ","[here]",". The user can store this txReceipt as it is a commitment used to verify the proof generated by the server."),(0,i.kt)("p",null,"Refer to ",(0,i.kt)("a",{parentName:"p",href:"../../queries/gosdk/simple-data-query"},"Query Data")," in queries to check whether ",(0,i.kt)("inlineCode",{parentName:"p"},"key1")," has been updated."),(0,i.kt)("h2",{id:"3-delete-an-existing-state"},"3) Delete an existing state"),(0,i.kt)("h3",{id:"31-source-code"},"3.1) Source Code"),(0,i.kt)("p",null,"Let's delete the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key1"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "strconv"\n)\n\nfunc main() {\n    db, err := createConnection()\n    // if err is not nil, print and return\n\n    session, err := openSession(db, "alice")\n    // if err is not nil, print and return\n\n    tx, err := session.DataTx()\n    // if err is not nil, print and return\n\n    err = tx.Delete("db2", "key1")\n    // if err is not nil, print and return\n\n    txID, receipt, err := tx.Commit(true)\n    // if err is not nil, print and return\n\n    fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))\n}\n')),(0,i.kt)("h3",{id:"32-source-code-commentary"},"3.2) Source Code Commentary"),(0,i.kt)("p",null,"For the sake of simplicity, not all errors are handled in this code. Furthermore, the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"createConnection()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"openSession()"),"\ncan be found ",(0,i.kt)("a",{parentName:"p",href:"../../pre-requisite/gosdk"},"here"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"session.DataTx()")," starts a new data transaction and returns the data transaction context. We can then perform all data manipulation activities using this transaction context."),(0,i.kt)("p",null,"To delete the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key1"),", we need to call ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Delete("db2", "key1")'),". Note that this is a blind delete. If you want to avoid the blind delete, we need to first fetch ",(0,i.kt)("inlineCode",{parentName:"p"},"key1")," by calling ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Get("db2", "key1")')," but ignoring the returned value and version. Next, we need to call ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Delete("db2", "key1")')," to delete the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key1"),"."),(0,i.kt)("p",null,"Finally, the transaction is committed by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"tx.Commit(true)"),'. The argument "true" denotes that this is a synchronous submission. As a result, the ',(0,i.kt)("inlineCode",{parentName:"p"},"Commit()"),"\nreturns the transaction receipt if this transaction gets committed before the ",(0,i.kt)("inlineCode",{parentName:"p"},"TxTimeout")," configured in the ",(0,i.kt)("inlineCode",{parentName:"p"},"openSession()"),"."),(0,i.kt)("p",null,"The structure of txReceipt can be seen ","[here]",". The user can store this txReceipt as it is a commitment used to verify the proof generated by the server."),(0,i.kt)("h2",{id:"4-create-update-and-delete-states-within-a-single-transaction"},"4) Create, update, and delete states within a single transaction"),(0,i.kt)("details",null,(0,i.kt)("summary",null," Let's create `key1` and `key2` so that in the next transaction we can do all three operations"),".",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "encoding/json"\n    "fmt"\n    "strconv"\n\n    "github.com/hyperledger-labs/orion-server/pkg/types"\n)\n\ntype person struct {\n    Name      string `json:"name"`\n    Age       int64  `json:"age"`\n    Graduated bool   `json:"graduated"`\n}\n\nfunc main() {\n    db, err := createConnection()\n    // if err is not nil, print and return\n\n    session, err := openSession(db, "alice")\n    // if err is not nil, print and return\n\n    tx, err := session.DataTx()\n    // if err is not nil, print and return\n\n    p1 := &person{\n        Name:      "abc",\n        Age:       31,\n        Graduated: true,\n    }\n\n    jVal, err := json.Marshal(p1)\n    // if err is not nil, print and return\n\n    acl := &types.AccessControl{\n        ReadUsers: map[string]bool{\n            "alice": true,\n            "bob":   true,\n        },\n        ReadWriteUsers: map[string]bool{\n            "alice": true,\n        },\n    }\n    err = tx.Put("db2", "key1", jVal, acl)\n    // if err is not nil, print and return\n\n    p2 := &person{\n        Name:      "def",\n        Age:       20,\n        Graduated: false,\n    }\n\n    jVal, err = json.Marshal(p2)\n    // if err is not nil, print and return\n\n    err = tx.Put("db2", "key2", jVal, acl)\n    // if err is not nil, print and return\n\n    txID, receipt, err := tx.Commit(true)\n    // if err is not nil, print and return\n\n    fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))\n}\n'))),(0,i.kt)("h3",{id:"41-source-code"},"4.1) Source Code"),(0,i.kt)("p",null,"Now that we have the required data in the server, we can create, update, and delete within a single transaction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "encoding/json"\n    "fmt"\n    "strconv"\n\n    "github.com/hyperledger-labs/orion-sdk-go/pkg/bcdb"\n    "github.com/hyperledger-labs/orion-server/pkg/types"\n)\n\ntype person struct {\n    Name      string `json:"name"`\n    Age       int64  `json:"age"`\n    Graduated bool   `json:"graduated"`\n}\n\nfunc main() {\n    db, err := createConnection()\n    // if err is not nil, print and return\n\n    session, err := openSession(db, "alice")\n    // if err is not nil, print and return\n\n    tx, err := session.DataTx()\n    // if err is not nil, print and return\n\n    err = createKey3(tx)\n    // if err is not nil, print and return\n\n    err = updateKey2(tx)\n    // if err is not nil, print and return\n\n    err = deleteKey1(tx)\n    // if err is not nil, print and return\n\n    txID, receipt, err := tx.Commit(true)\n    // if err is not nil, print and return\n\n    fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))\n}\n\nfunc createKey3(tx bcdb.DataTxContext) error {\n    p1 := &person{\n        Name:      "ghi",\n        Age:       24,\n        Graduated: true,\n    }\n\n    jVal, err := json.Marshal(p1)\n    if err != nil {\n        return err\n    }\n\n    acl := &types.AccessControl{\n        ReadWriteUsers: map[string]bool{\n            "alice": true,\n        },\n    }\n\n    return tx.Put("db2", "key3", jVal, acl)\n}\n\nfunc updateKey2(tx bcdb.DataTxContext) error {\n    v, m, err := tx.Get("db2", "key2")\n    if err != nil {\n        return err\n    }\n\n    p := &person{}\n    err = json.Unmarshal(v, p)\n    if err != nil {\n        return err\n    }\n    p.Age = 24\n    p.Graduated = true\n\n    jVal, err := json.Marshal(p)\n    if err != nil {\n        return err\n    }\n\n    return tx.Put("db2", "key2", jVal, m.AccessControl)\n}\n\nfunc deleteKey1(tx bcdb.DataTxContext) error {\n    return tx.Delete("db2", "key1")\n}\n')),(0,i.kt)("h3",{id:"42-source-code-commentary"},"4.2) Source Code Commentary"),(0,i.kt)("p",null,"For the sake of simplicity, not all errors are handled in this code. Further, the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"createConnection()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"openSession()"),"\ncan be found ",(0,i.kt)("a",{parentName:"p",href:"../../pre-requisite/gosdk"},"here"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"session.DataTx()")," starts a new data transaction and returns the data transaction context. We can then perform all data manipulation activities using this transaction context."),(0,i.kt)("p",null,"It can be clearly seen from the source that we use the same transaction context to create a new key ",(0,i.kt)("inlineCode",{parentName:"p"},"key3"),",\nupdate an existing key ",(0,i.kt)("inlineCode",{parentName:"p"},"key2"),", and delete an existing key ",(0,i.kt)("inlineCode",{parentName:"p"},"key1"),"."),(0,i.kt)("p",null,"The value for ",(0,i.kt)("inlineCode",{parentName:"p"},"key3")," is created by marshaling the ",(0,i.kt)("inlineCode",{parentName:"p"},"person")," object. Then, ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Put("db2", "key3", jVal, acl)')," stores\n",(0,i.kt)("inlineCode",{parentName:"p"},"key3")," with the value ",(0,i.kt)("inlineCode",{parentName:"p"},'{"name":"ghi","age":24,"graduated":true}'),". Only ",(0,i.kt)("inlineCode",{parentName:"p"},"alice")," has read and write permission on ",(0,i.kt)("inlineCode",{parentName:"p"},"key3")," as defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadWriteUsers")," access control list."),(0,i.kt)("p",null,"For updating ",(0,i.kt)("inlineCode",{parentName:"p"},"key2"),", first, we fetch ",(0,i.kt)("inlineCode",{parentName:"p"},"key2")," by calling ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Get("db2", "key2")'),". Next, the fetched value is unmarshalled\ninto a person object such that fields such as ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"graduated")," can be updated. Then, the updated value is\nstored by calling ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Put("db2", "key2", jVal, m.AccessControl)'),"."),(0,i.kt)("p",null,"Finally, the transaction is committed by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"tx.Commit(true)"),'. The argument "true" denotes that this is a synchronous submission. As a result, the ',(0,i.kt)("inlineCode",{parentName:"p"},"Commit()"),"\nreturns the transaction receipt if this transaction gets committed before the ",(0,i.kt)("inlineCode",{parentName:"p"},"TxTimeout")," configured in the ",(0,i.kt)("inlineCode",{parentName:"p"},"openSession()"),"."),(0,i.kt)("p",null,"The structure of txReceipt can be seen ","[here]",". The user can store this txReceipt as it is a commitment used to verify the proof generated by the server."),(0,i.kt)("p",null,"Refer to ",(0,i.kt)("a",{parentName:"p",href:"../../queries/gosdk/simple-data-query"},"Query Data")," in queries to check whether ",(0,i.kt)("inlineCode",{parentName:"p"},"key3")," has been created,\n",(0,i.kt)("inlineCode",{parentName:"p"},"key2")," has been updated, and ",(0,i.kt)("inlineCode",{parentName:"p"},"key1")," has been deleted."),(0,i.kt)("h2",{id:"5-operations-on-multiple-databases-in-a-single-transaction"},"5) Operations on Multiple Databases in a Single Transaction"),(0,i.kt)("p",null,"A data transaction can access or modify more than one user database in a transaction. In the below example,\nwe perform operations on two databases, ",(0,i.kt)("inlineCode",{parentName:"p"},"db1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"db2"),", within a single transaction."),(0,i.kt)("details",null,(0,i.kt)("summary",null," Update `alice`'s privileges "),"As both `alice` and `bob` have only read permission on the database `db1`, first, we update the privilege of `alice` to have read-write permission on `db1` as shown below:",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "strconv"\n\n    "github.com/hyperledger-labs/orion-server/pkg/types"\n)\n\nfunc main() {\n    bcdb, err := createConnection()\n    // if err is not nil, print and return\n\n    session, err := openSession(bcdb, "admin")\n    // if err is not nil, print and return\n\n    tx, err := session.UsersTx()\n    // if err is not nil, print and return\n\n    alice, err := tx.GetUser("alice")\n    // if err is not nil, print and return\n\n    alice.Privilege.DbPermission = map[string]types.Privilege_Access{\n        "db1": 1,\n        "db2": 1,\n    }\n    err = tx.PutUser(alice, nil)\n    // if err is not nil, print and return\n\n    txID, receipt, err := tx.Commit(true)\n    // if err is not nil, print and return\n\n    fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))\n}\n'))),(0,i.kt)("h3",{id:"51-source-code"},"5.1) Source Code"),(0,i.kt)("p",null,"Let's create"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Key ",(0,i.kt)("inlineCode",{parentName:"li"},"key4")," with value ",(0,i.kt)("inlineCode",{parentName:"li"},'{"name":"abc","age":31,"graduated":true}')," in ",(0,i.kt)("inlineCode",{parentName:"li"},"db1")),(0,i.kt)("li",{parentName:"ol"},"Key ",(0,i.kt)("inlineCode",{parentName:"li"},"key4")," with value ",(0,i.kt)("inlineCode",{parentName:"li"},'{"name":"def","age":20,"graduated":false}')," in ",(0,i.kt)("inlineCode",{parentName:"li"},"db2"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "encoding/json"\n    "fmt"\n    "strconv"\n\n    "github.com/hyperledger-labs/orion-sdk-go/pkg/bcdb"\n    "github.com/hyperledger-labs/orion-server/pkg/types"\n)\n\ntype person struct {\n    Name      string `json:"name"`\n    Age       int64  `json:"age"`\n    Graduated bool   `json:"graduated"`\n}\n\nfunc main() {\n    db, err := createConnection()\n    // if err is not nil, print and return\n\n    session, err := openSession(db, "alice")\n    // if err is not nil, print and return\n\n    tx, err := session.DataTx()\n    // if err is not nil, print and return\n\n    err = createKey4InDB1(tx)\n    // if err is not nil, print and return\n\n    err = createKey4InDB2(tx)\n    // if err is not nil, print and return\n\n    txID, receipt, err := tx.Commit(true)\n    // if err is not nil, print and return\n\n    fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))\n}\n\nfunc createKey4InDB1(tx bcdb.DataTxContext) error {\n    p1 := &person{\n        Name:      "abc",\n        Age:       31,\n        Graduated: true,\n    }\n\n    jVal, err := json.Marshal(p1)\n    if err != nil {\n        return err\n    }\n\n    acl := &types.AccessControl{\n        ReadUsers: map[string]bool{\n            "bob":   true,\n        },\n        ReadWriteUsers: map[string]bool{\n            "alice": true,\n        },\n    }\n\n    return tx.Put("db1", "key4", jVal, acl)\n}\n\nfunc createKey4InDB2(tx bcdb.DataTxContext) error {\n    p2 := &person{\n        Name:      "def",\n        Age:       20,\n        Graduated: false,\n    }\n\n    jVal, err := json.Marshal(p2)\n    if err != nil {\n        return err\n    }\n\n    return tx.Put("db2", "key4", jVal, nil)\n}\n')),(0,i.kt)("h3",{id:"52-source-code-commentary"},"5.2) Source Code Commentary"),(0,i.kt)("p",null,"For the sake of simplicity, not all errors are handled in this code. Further, the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"createConnection()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"openSession()"),"\ncan be found ",(0,i.kt)("a",{parentName:"p",href:"../../pre-requisite/gosdk"},"here"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"session.DataTx()")," starts a new data transaction and returns the data transaction context. We can then perform all data manipulation activities using this transaction context."),(0,i.kt)("p",null,"In database ",(0,i.kt)("inlineCode",{parentName:"p"},"db1"),", we create a key ",(0,i.kt)("inlineCode",{parentName:"p"},"key4")," with the value ",(0,i.kt)("inlineCode",{parentName:"p"},'{"name":"abc","age":31,"graduated":true}')," using the person object and\njson marshal. Then, the value is stored by calling ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Put("db1", "key4", jVal, acl)'),". Note that the first parameter is ",(0,i.kt)("inlineCode",{parentName:"p"},"db1"),".\nAs per the ACL, ",(0,i.kt)("inlineCode",{parentName:"p"},"bob")," has only read permission, while ",(0,i.kt)("inlineCode",{parentName:"p"},"alice")," has both read and write permissions."),(0,i.kt)("p",null,"In database ",(0,i.kt)("inlineCode",{parentName:"p"},"db2"),", we create a key ",(0,i.kt)("inlineCode",{parentName:"p"},"key4")," with the value ",(0,i.kt)("inlineCode",{parentName:"p"},'{"name":"def","age":20,"graduated":false}')," using the person object and\njson marshal. Then, the value is stored by calling ",(0,i.kt)("inlineCode",{parentName:"p"},'tx.Put("db2", "key4", jVal, nil)'),". Note that the first parameter is ",(0,i.kt)("inlineCode",{parentName:"p"},"db1"),".\nFurther, there is no ACL on ",(0,i.kt)("inlineCode",{parentName:"p"},"key4"),". As a result, both ",(0,i.kt)("inlineCode",{parentName:"p"},"alice")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bob")," can read or write to ",(0,i.kt)("inlineCode",{parentName:"p"},"key4"),". In fact, any new user of Orion can read or write to ",(0,i.kt)("inlineCode",{parentName:"p"},"key4")," when the ACL is empty."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Additional Examples")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"In addition to this example, you can download and use the data transaction examples from the go-sdk examples folder: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hyperledger-labs/orion-sdk-go/blob/main/examples/api/simple_tx/simple_tx.go"},"orion-sdk-go/examples/api/simple_tx/simple_tx.go")))))}u.isMDXComponent=!0}}]);